# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'programUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import threading
import requests
import random
from datetime import datetime
from bs4 import BeautifulSoup
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtWidgets import QApplication

num_threads : int

# array of urls to check
URLs = []
url_queue = []


#array of url names
URL_names = []

# array to store each product log
logs = []
logs.queue = []

stop_checking = False

product_name = ""


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        
        #set MainWindow minimum size to 800x600
        MainWindow.setMinimumSize(QtCore.QSize(800, 600))

        #set MainWindow maximum size to 1200x720
        MainWindow.setMaximumSize(QtCore.QSize(1200, 720))
        

        # set up the main window
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        # set up the stop button
        self.stop_button = QtWidgets.QPushButton(self.centralwidget, clicked=lambda: self.stop_button_clicked())
        self.stop_button.setGeometry(QtCore.QRect(110, 40, 75, 23))
        self.stop_button.setObjectName("stop_button")
        # set stop button to disabled by default
        self.stop_button.setEnabled(False)

        # set up the logs output
        self.logs_output = QtWidgets.QTextEdit(self.centralwidget, readOnly=True)
        self.logs_output.setGeometry(QtCore.QRect(410, 20, 381, 531))
        self.logs_output.setTextInteractionFlags(QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)
        self.logs_output.setObjectName("log_output")

        # set up the start button
        self.start_button = QtWidgets.QPushButton(self.centralwidget, clicked=lambda: self.start_button_clicked())
        self.start_button.setGeometry(QtCore.QRect(30, 40, 75, 23))
        self.start_button.setObjectName("start_button")

        # set up the list of urls
        self.URLs_view = QtWidgets.QListView(self.centralwidget)
        self.URLs_view.setGeometry(QtCore.QRect(30, 350, 321, 192))
        self.URLs_view.setUniformItemSizes(False)
        self.URLs_view.setObjectName("URLs_view")

        # set up the url input
        self.URL_input = QtWidgets.QTextEdit(self.centralwidget)
        self.URL_input.setGeometry(QtCore.QRect(30, 310, 321, 31))
        self.URL_input.setAcceptDrops(True)
        self.URL_input.setInputMethodHints(QtCore.Qt.ImhMultiLine|QtCore.Qt.ImhUrlCharactersOnly)
        self.URL_input.setAcceptRichText(False)
        self.URL_input.setObjectName("URL_input")

        # set up the add button
        self.add_button = QtWidgets.QPushButton(self.centralwidget, clicked=lambda: self.add_URL())
        self.add_button.setGeometry(QtCore.QRect(30, 250, 75, 23))
        self.add_button.setObjectName("add_button")

        # set up the delete button
        self.delete_button = QtWidgets.QPushButton(self.centralwidget, clicked=lambda: self.delete_URL())
        self.delete_button.setEnabled(True)
        self.delete_button.setGeometry(QtCore.QRect(110, 250, 75, 23))
        self.delete_button.setObjectName("delete_button")
        # set delete button to disabled by default
        self.delete_button.setEnabled(False)

        # set up the radio button group
        self.radio_button_group = QtWidgets.QButtonGroup()
        self.radio_button_group.setObjectName("radio_button_group")
        self.radio_button_group.setExclusive(True)

        # set up the radio buttons
        self.URL_0_radio_button = QtWidgets.QRadioButton(self.centralwidget)
        self.URL_0_radio_button.setGeometry(QtCore.QRect(40, 360, 300, 17))
        self.URL_0_radio_button.setObjectName("URL_0_radio_button")
        self.URL_1_radio_button = QtWidgets.QRadioButton(self.centralwidget)
        self.URL_1_radio_button.setGeometry(QtCore.QRect(40, 380, 300, 17))
        self.URL_1_radio_button.setObjectName("URL_1_radio_button")
        self.URL_2_radio_button = QtWidgets.QRadioButton(self.centralwidget)
        self.URL_2_radio_button.setGeometry(QtCore.QRect(40, 400, 300, 17))
        self.URL_2_radio_button.setObjectName("URL_2_radio_button")
        self.URL_3_radio_button = QtWidgets.QRadioButton(self.centralwidget)
        self.URL_3_radio_button.setGeometry(QtCore.QRect(40, 420, 300, 17))
        self.URL_3_radio_button.setObjectName("URL_3_radio_button")
        self.URL_4_radio_button = QtWidgets.QRadioButton(self.centralwidget)
        self.URL_4_radio_button.setGeometry(QtCore.QRect(40, 440, 300, 17))
        self.URL_4_radio_button.setObjectName("URL_4_radio_button")
        self.URL_5_radio_button = QtWidgets.QRadioButton(self.centralwidget)
        self.URL_5_radio_button.setGeometry(QtCore.QRect(40, 460, 300, 17))
        self.URL_5_radio_button.setObjectName("URL_5_radio_button")

        #add the radio buttons to the group
        self.radio_button_group.addButton(self.URL_0_radio_button)
        self.radio_button_group.addButton(self.URL_1_radio_button)
        self.radio_button_group.addButton(self.URL_2_radio_button)
        self.radio_button_group.addButton(self.URL_3_radio_button)
        self.radio_button_group.addButton(self.URL_4_radio_button)
        self.radio_button_group.addButton(self.URL_5_radio_button)

        # set up the thread count spin box
        self.thread_selector = QtWidgets.QSpinBox(self.centralwidget)
        self.thread_selector.valueChanged.connect(self.update_num_threads)
        self.thread_selector.setGeometry(QtCore.QRect(30, 70, 42, 22))
        self.thread_selector.setMinimum(1)
        self.thread_selector.setMaximum(4)
        self.thread_selector.setObjectName("thread_selector")

        # set up the thread count label
        self.thread_count_label = QtWidgets.QLabel(self.centralwidget)
        self.thread_count_label.setEnabled(True)
        self.thread_count_label.setGeometry(QtCore.QRect(80, 70, 71, 16))
        self.thread_count_label.setObjectName("thread_count_label")

        # set up the QTimer
        self.timer = QtCore.QTimer
        self.timer.timeout.connect(self.stock_checker)


        # misc. setup
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "REMO's Stock Checker"))
        self.start_button.setText(_translate("MainWindow", "Start"))
        self.stop_button.setText(_translate("MainWindow", "Stop"))
        self.add_button.setText(_translate("MainWindow", "Add"))
        self.delete_button.setText(_translate("MainWindow", "Delete"))
        self.URL_0_radio_button.setText(_translate("MainWindow", "No URL"))
        self.URL_1_radio_button.setText(_translate("MainWindow", "No URL"))
        self.URL_2_radio_button.setText(_translate("MainWindow", "No URL"))
        self.URL_3_radio_button.setText(_translate("MainWindow", "No URL"))
        self.URL_4_radio_button.setText(_translate("MainWindow", "No URL"))
        self.URL_5_radio_button.setText(_translate("MainWindow", "No URL"))
        self.thread_count_label.setText(_translate("MainWindow", "Thread Count"))


    #function that starts stockChecker
    def start_button_clicked(self):
        global stop_checking
        stop_checking = False
        #disable start button
        self.start_button.setEnabled(False)
        #disable add button
        self.add_button.setEnabled(False)
        #disable delete button
        self.delete_button.setEnabled(False)
        #disable thread spinbox
        self.thread_selector.setEnabled(False)
        #disable url input
        self.URL_input.setEnabled(False)
        #enable stop button
        self.stop_button.setEnabled(True)
        
        # run stockChecker every random amount of time between 3.0 to 6.0 seconds
        # theoretically, less likely to activate website captcha that would break the program
        self.timer.setInterval(int(random.uniform(3000, 6000)))
        self.timer.start()

        
    def stock_checker(self):
        global URLs
        global num_threads
        global logs
        
        #split URLs into chunks evenly
        urlChunks = [URLs[i::num_threads] for i in range(num_threads)]

        
        #initialize logs
        logs = ["" for i in range(len(URLs))]

        # any error that may occur will either be caused by spam detection or website traffic/outage
        try:
            # initialize mutex lock
            lock = threading.Lock()

            # create threads to handle each url
            for i in range(num_threads):
                thread = threading.Thread(target=parse_html_response, args=(lock, urlChunks[i], i, self,))
                thread.start()

            # joins threads together when done. newEgg() will not run anymore in this iteration
            for i in range(num_threads):
                thread.join()

            # update logsOutput
            self.update_logs_output()

        except Exception as e:
            # handles any error that may occur as stated above, and quits the program accordingly.
            self.update_logs_output('ERROR: Caught by Captcha, or the url is invalid!')
            self.stop_button_clicked()
        

    def stop_button_clicked(self):
        global stop_checking
        stop_checking = True
        #disable stop button
        self.stop_button.setEnabled(False)
        #enable start button
        self.start_button.setEnabled(True)
        #enable add button
        self.add_button.setEnabled(True)
        #enable delete button
        self.delete_button.setEnabled(True)
        #enable thread spinbox
        self.thread_selector.setEnabled(True)
        #enable url input
        self.URL_input.setEnabled(True)

        #stop stockChecker
        self.timer.stop()

    
    #function that adds a url from url_input to the listview
    def add_URL(self):
        #get url from url_input
        global URLs
        global URL_names
        #add url to urlsView
        #add url to the first empty url_radioButton
        for radio_button in self.radio_button_group.buttons():
            if (radio_button.text() == "No URL") & (self.URL_input.toPlainText() != ""):
                # add url to urlsView
                URLs.append(self.URL_input.toPlainText())
                # add product name to URL_names
                URL_names.append(self.URL_input.toPlainText())
                #set radio button text to url
                radio_button.setText(self.URL_input.toPlainText())
                #set threadSpinBox maximum to the number of urls
                self.thread_selector.setMaximum(len(URLs))
                break
        self.URL_input.clear()
        #enable delete button if there are urls
        self.delete_button.setEnabled(True)
    
    #function that deletes the selected url from the listview
    def delete_URL(self):
        global URLs
        global URL_names
        #delete url from urlsView
        for radio_button in self.radio_button_group.buttons():
            if radio_button.isChecked() & (radio_button.text() != "No URL") & (self.URL_input.toPlainText() == ""):
                #get index of url in urlsView
                url_name_index = URL_names.index(radio_button.text())
                #delete url from based on radio button selected
                URLs.remove(URLs[url_name_index])
                URL_names.remove(URL_names[url_name_index])
                radio_button.setText("No URL")
                break
        self.URL_input.clear()
        #disable delete button if there are no more urls
        if len(URLs) == 0:
            self.delete_button.setEnabled(False)
        
    #function that updates the radio button text to the prduct name 
    def update_radio_button_text(self, URL, product_name):
        for radio_button in self.radio_button_group.buttons():
            if radio_button.text() == URL:
                radio_button.setText(product_name)
                break


    #function that updates the number of threads
    def update_num_threads(self):
        global num_threads
        num_threads = self.thread_selector.value()

    # function that redoes the log output and adds a blankline after each log element
    def update_logs_output(self):
        global logs
        self.logs_output.clear()
        self.logs_output.append("\n\n".join(logs))



# function that prevents the thread count from being higher than the number of URLs        
def check_thread_count(myWindow):
    global num_threads
    if num_threads > len(URLs):
        num_threads = len(URLs)
        myWindow.thrad_selector.setValue(num_threads)

# function that returns the current time in the format of HH:MM:SS AM/PM Timezone
def get_time():
    # timezone formatting 12 hour clock with AM/PM and timezone
    return datetime.now().strftime("%I:%M:%S %p %Z")

#function that hands the url to the delegate for a post request and returns the HTML response
def get_html_response(url):
    local = "http://localhost:5000/api/v1/request"
    jsonData = {"apikey": "cffb0029-bbfe-40c0-8f20-fc76c15fd51b",
                "url": url}
    response = requests.post(local, json=jsonData)

    # string holding all HTML code
    return str(response.content)


# function that parses the HTML response and defines the item's contents
def parse_html_response(lock, url_chunk, tid, my_window):

    for i in range(len(url_chunk)):
        lock.acquire()
        url = url_chunk[i]
        url_index = URLs.index(url)
        # HTML Response Data
        html_response = get_html_response(url)
        # Parse the relevant information from the HTML response
        try: 
            global product_name
            global URL_names
            product_name = html_response[html_response.index('<title>') + 7:html_response.index('</title>') - 13]
            URL_names[url_index] = product_name
            #find the radio button that matches the url
            for radio_buttom in my_window.radio_button_group.buttons():
                if radio_buttom.text() == url:
                    #update the radio button with the product name
                    my_window.update_radio_button_text(url, product_name)
                    break
        except ValueError:
            in_stock_log = f"{current_time} ERROR: product_name NOT FOUND"
        
        current_time = get_time()

        try:
            price = html_response[html_response.index('"FinalPrice":') + 13:html_response.index('"Instock"') - 1]
        except ValueError:
            in_stock_log = f"{current_time} ERROR: price NOT FOUND"
        
        try:
            shipping = html_response[html_response.index('"ShippingCharge"') + 17:html_response.index('"VFAvail"') - 1]
        except ValueError:
            in_stock_log = f"{current_time} ERROR: shipping NOT FOUND"

        try:
            quantity = int(html_response[html_response.index('"Qty":')+6:html_response.index('"UnitCost"') - 1])
        except ValueError:
            in_stock_log = f"{current_time} ERROR: quantity NOT FOUND"

        try:
            in_stock = bool(html_response[html_response.index('"Instock"') + 10:html_response.index('"Stock"') - 1])
        except ValueError:
            in_stock_log = f"{current_time} ERROR: in_stock NOT FOUND"


        if in_stock:
            # Create the log message for in-stock items
            in_stock_log = f"{current_time} NEWEGG - {product_name} | Price: ${price} Shipping Cost: ${shipping} Quantity: {quantity}"

            # Store the log message in the appropriate index of the logs array
            logs[(len(url_chunk)*tid) + i] = in_stock_log
        else:
            # Create the log message for out-of-stock items
            out_of_stock_log = f"{current_time} NEWEGG - {product_name} | OUT OF STOCK"

            # Store the log message in the appropriate index of the logs array
            logs[(len(url_chunk)*tid) + i] = out_of_stock_log

        lock.release()


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
